# 🖇️ 암호학

- 암호학 연구는 암호화라고 하는 단순한 비밀 작성 이상의 것을 포함한다.

- 암호학은 그 비밀을 밝히지 않고 비밀의 지식을 증명하거나 (디지털 서명)

- 데이터의 진위성을 증명하는데 사용할 수 있다. (해시)

- 이더리움 플랫폼과 노드 간(트랜잭션 데이터 포함)의 모든 통신은 암호화되어 있지 않고 누구나 그 내용을 읽을 수 있다.

## 📑 키와 주소

- 디지털 개인키, 이더리움 주소, 디지털 서명을 통해 외보 소유 계정의 이더 소유권을 확립한다.

- 계정 주소는 개인키에서 직접 파생되고, 개인키는 계정(account)이라고도 불리는 단일 이더리움 주소를 고유하게 결정한다.

- 사용자가 자신의 개인키를 안전하게 유지한다면, 이더리움 트랜잭션의 디지털 서명은 개인키의 소유권을 증명하기 때문에 자금의 실제 소유자임도 증명한다.

- 이더리움에서 사용하는 것과 같은 공개키 암호화 기반 시스템에서는 키는 개인키와 공개키로 구성된 쌍으로 제공한다.

## 📑 공개키 암호화와 암호화폐

- 역산하기 위한 단축키로 사용할 수 있는 비밀 정보가 없으면 거꾸로 계산하기 어려운 함수를 트랩도어 함수라고 한다.

- 타원 곡선 산술에서 소수로 나눈 나머지를 곱하는 것은 간단하지만, 나눗셈은 사실상 불가능한데 이것을 이산 로그 문제(discrete logarithm problem)이라고 한다.

- 공개키는 개인키에서 파생되므로 '쌍'으로 간주한다.

- 그와 함께, 그 쌍은 공개적으로 접근할 수 있는 계정 핸들(주소)과 계정의 이더에 대한 접근 권한, 그리고 스마트 컨트랙트를 사용하라 때 계정이 필요로 하는 모든 인증에 대한 사적 제어권을 제공함으로써 이더리움 계정을 나타낸다.

- 이더리움 트랜잭션에서는 트랜잭션 자체의 세부사항이 메시지로 사용된다. 암호 수학은(타원 곡선 암호화) 메시지(트랜잭션 세부 정보)를 개인키와 결합하여 개인키를 알아야만 만들 수 있는 코드 생성 방법을 제공하며 이 코드를 디지털 서명이라고 한다.

- 이더리움 트랜잭션은 기본적으로 특정 이더리움 주소로 특정 계정에 접근하는 요청이다. 자금을 이동하거나 스마트 컨트랙트와 상호작용하기 위해 트랜잭션을 이더리움 네트워크로 보내면, 문제의 이더리움 주소에 해당하는 개인키로 생성된 디지털 서명도 함께 보내야 한다.

- 타원 곡선 수학이란 디지털 서명, 트랜잭션 세부 정보, 접근하려는 이더리움 주소가 일치하는지 확인하여 '누구나' 트랜잭션이 유효한지 확인할 수 있음을 의미한다. 이러한 확인과정에서 개인키는 전혀 포함되지 않는다.

## 📑 개인키

- 개인키는 단순히 무작위로 선택한 숫자다.

### 🏷️ 난수로 개인키 생성

- 키를 생성하는 가장 중요한 첫 번째 단계는 엔트로피, 즉 무작위성을 확보하는 것이다.

- 이더리움 소프트웨어는 기본 운영체제의 난수 생성기를 사용하여 256개의 임의 비트를 생성한다.

- 프로그래밍 측면세어 이것은 일반적으로 더 큰 임의의 비트 문자열(암호학적으로 안전한 임의성 소스에서 수집됨)을 **Keccak-256** 또는 **SHA-256** 같은 256비트 해시 알고리즘에 공급함으로써 이루어진다.

## 📑 개인키

- 이더리움 공개키는 타원 곡선에 있는 점으로 타원 곡선 방정식을 만족하는 x와 y좌표의 집합을 의미한다.

- 이 숫자는 개인키로부터 '단방향으로만' 계산할 수 있다.

- 공개키는 사실상 비가역적인 타원 곡선 곱셈을 사용하여 개인키로부터 계산된다.

### 🏷️ 타원 곡선 암호화 설명

- secp256k1이라는 NIST(National Institue of Standards and Technology, NIST)에서 제정한 표준에 정의한대로 곡선과 수학 상수 집합을 사용한다.

  y 2 = ( x 3 + 7 ) over ( 𝔽 p )

  or:

  y 2 mod p = ( x 3 + 7 ) mod p

  p = 2256 – 232 – 29 – 28 – 27 – 26 – 24 – 1

### 🏷️ 타원 곡선 산술 연산

- P3 = P1 + P2를 정의하는 방식은 P3를 P1과 P2사이의 선을 그려서 계산할 수 있는데, 이 선은 정확히 하나의 추가 장소에서 타원곡선과 교차하며 이 점을 x축에 대칭하여 P3을 계산한다.

- x값이 동일하며 x축에 대칭인 두 점의 덧셈은 0으로 취급한다.

### 🏷️ 공개키 생성

- 무작위로 생성한 숫자 k형태의 개인키로 시작하여 생성자 점(generator point)G라고 하는 곡선의 미리 결정된 점에 개인키를 곱하여 곡선상의 다른 점에 대응하는 공개키 K를 생성한다.

- secp256k1에는 정해진 G가 존재하므로 G와 k를 곱한 결과가 항상 동일하다.

### 🏷️ 타원 곡선 라이브러리

- OpenSSL

- libsecp256k1

  비트코인 코어의 라이브러리로 C언어로 구현

## 📑 암호화 해시 함수

- "암호화 알고리즘보다 단방향 해시 함수들이 현대 암호학을 더 잘 이끄는 견인차이다" - 브루스 슈나이어

- 데이터 확인에 도움이 되는 디지털 지문(digital fingerprints)을 만드는데 사용할 수 있다.

- 간단히 말하면, 해시 함수는 임의의 크기의 데이터를 고정된 크기의 데이터로 매핑하는 데 사용할 수 있는 모든 함수다.

- 해시 함수에 대한 입력을 사전이미지, 메시지 또는 단순히 입력 데이터라고 한다. 그리고 그 결과는 해시라고 한다.

- 해시 함수는 단방향 해시함수이다. 단 방향이란 결과값 해시만 알고 있을 때 입력 데이터를 다시 작성하는 것이 계산적으로 불가능함을 의미한다.

- 암호화 해시 함수의 주요 속성

  1.  결정론 (deterministic)

            주어진 입력 메시지는 항상 동일한 해시 결과를 생성한다.

  2.  검증성 (verifiability)

            메시지의 해시 계산은 효율적이다.(선형 복잡성)

  3.  비상관성 (noncorrelation)

            메시지에 대한 작은 변화는 해시 출력을 너무 광범위하게 변경해야 해서 원본 메시지의 해시와 상관 관계가 없다.

  4.  비가역성 (irreversibility)

            해시로부터 메시지를 계산하는 것은 불가능하다. 모든 가능한 메시지에 대한 무차별 검증(brute-force search)과 같다.

  5.  충돌 방지 (collision protection)

            같은 해시 결과를 생성하는 2개의 서로 다른 메시지를 계산하는 것은 불가능하다.

- 이러한 속성을 조합하면 암호화 해시 기능이 다음과 같은 다양한 보안 어플리케이션에 유용하다.

  1. 데이터 핑거프린팅
  2. 데이터 무결성 (오류 감지)
  3. 작업 증명
  4. 인증 (암호 해싱 및 키 스트레칭)
  5. 의사 난수 생성기
  6. 메시지 커밋 (커밋-공개 매커니즘)
  7. 고유 식별자

### 🏷️ 이러디움의 암호화 해시 함수: Keccak-256

### 🏷️ 어떤 해시 함수를 사용하고 있는가?

- 테스트 벡터, 빈 입력을 넣- 테스트 벡터, 빈 입력을 넣어서 나온 해시 값으로 SHA-3중에서도 FIPS-202 SHA-3인지 Keccak-256인지 판단한다.

## 📑 이더리움 주소

- 이더리움 주소는 Keccak-256 단방향 해시 함수를 사용하는 공개키 또는 컨트랙트에서 파생한 고유 식별자(unique identifier)이다

- 이더리움 주소를 만드는 과정

        k = f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315

        K = 6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b83b5c38e5e...

        Keccak256(K) = 2a5bc342ed616b5ba5732269001d3f1ef827552ae1114027bd3ecf1f086ba0f9

        # 위의 해시 값에서 마지막 20바이트만 유지하고 종종 접두어로 0x로 표시를 하며, 16진수로 표시한다

        001d3f1ef827552ae1114027bd3ecf1f086ba0f9

        0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9

### 🏷️ 이더리움 주소 형식

- 이더리움 주소는 16진수이며, 공개키 Keccak-256 해시의 마지막 20바이트에서 파생한 식별자이다

- 모든 클라이언트의 사용자 인터페이스에 내장된 체크섬을 포함하여 잘못 입력된 주소를 보호하도록 인코딩된 비트코인 주소와 달리 이더리움 주소는 체크섬이 없는 원시 16진수로 표시한다.

- 이 결정의 근거는 결국 상위 계층에서 추상화(예를 들어 이름 서비스)에 주소가 숨겨지고 필요하다면 상위 계층에 체크섬을 추가해야 한다는 것이다.

### 🏷️ 클라이언트 주소 상호교환 프로토콜

- 클라이언트 주소 상호교환 프로토콜 (Inter exchange Client Address Protocol, ICAP)은 국제 은행 계좌 번호(International Bank Account Number, IBAN) 인코딩과 부분적으로 호환되는 이더리움 주소 인코딩으로, 이더리움 주소에 대해 다목적의 체크섬이 가능하고 상호운용 가능한 인코딩을 제공한다.

- ICAP는 하지만 몇 가지 지갑에서만 지원한다.

### 🏷️ 대문자로 16진수 인코딩된 체크섬(EIP-55)

- ICAP와 네임 서비스의 느랜 배포 때문에 EIP(Eithereum Improvement Proposal)에서 표준을 제안했다.

- EIP-55는 16진수 주소의 대소문자를 수정하여 이더리움 주소에 대한 이전 버전과 호환되는 체크섬을 제공한다.

- 이더리움 주소는 대소문자를 구분하지 않으며, 모든 지갑은 해석의 차이 없이 대문자 또는 소문자로 표현된 이더리움의 주소를 수용해야 한다는 것

- 이를 지원하는 사용자는 주소를 확인하고 99.986%의 정확도로 오류를 감지할 수 있다.

- 소문자 16진수 주소의 Keccak-256 해시를 사용하는데, 이 해시는 주소의 디지털 지문 역할을 하여 편리한 체크섬을 제공한다.

        1. 0x 접두어 없이 소문자 주소를 해시 처리한다.

        2. 해시의 해당 16진수가 0x8이상인 경우 각 알파벳 문자를 대문자로 만들어라. 주소와 해시를 정렬하면 표시하기가 더 쉽다.

        Keccak256("001d3f1ef827552ae1114027bd3ecf1f086ba0f9") =
            23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9695d9a19d8f673ca991deae1

        Address: 001d3f1ef827552ae1114027bd3ecf1f086ba0f9
        Hash   : 23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9...

        Address: 001d3F1ef827552Ae1114027BD3ECF1f086bA0F9
        Hash   : 23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9...

- 주소에서 마지막 두번째 문자 F를 E로 잘못 읽었다고 가정하고 잘못된 주소를 지갑에 입력한다면

- 지갑이 EIP-55를 준수한다면 대소문자가 혼용되었음을 확인하고 주소의 유효성을 검사한다. 소문자로 변환하고 체크섬 해시를 계산한다.

- 입력한 주소의 대문자 사용은 계산된 체크섬과 일치하지 않으므로 주소가 변경되어 오류가 발생한다.

        0x001d3F1ef827552Ae1114027BD3ECF1f086bA0E9

        Keccak256("001d3f1ef827552ae1114027bd3ecf1f086ba0e9") =
            5429b5d9460122fb4b11af9cb88b7bb76d8928862e0a57d46dd18dd8e08a6927

        001d3F1ef827552Ae1114027BD3ECF1f086bA0E9
        5429b5d9460122fb4b11af9cb88b7bb76d892886...
