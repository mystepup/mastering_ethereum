# 🖇️ 이더리움 클라이언트

- *이더리움 클라이언트*는 이더리움 사양을 구현하고 다른 이더리움 클라이언트와 P2P네트워크를 통해 통신하는 소프트웨어 어플리케이션이다. 기준 사양과 표준 통신 프로토콜을 준수한다면 서로 다른 이더리움 클라이언트끼리 상호운용(interporate)이 가능하다.

- 이더리움은 황서라는 공식 사양에 의해 정의된다.

- 비트코인의 '사양'이 비트코인 비트코인 코어의 구현 기준인 반면, 이더리움은 영어, 수학사양이 결합되어 문서화되어 있다.

- 이 공식 사양은 다양한 이더리움 개선 제안(EIP)과 함께 이더리움 클라이언트의 표준 작동 방식을 정의한다.

- 특정 클라이언트의 구현 전략을 악용하는 것은 개발자가 공격을 패치하는 동안 개발자를 괴롭히지만 다른 클라이언트는 네트워크에 거의 영향을 주지 않는다.

## 📑 이더리움 네트워크

- 이더리움 프로토콜의 여섯 가지 기본 구현이 있다.

  1. Rust로 작성된 Parity
  2. Go로 작성된 Geth
  3. C++로 작성된 cpp-ethereum
  4. Python으로 작성된 pyethereum
  5. Scala로 작성된 Mantis
  6. Java로 작성된 Harmony

    <br>

### 🏷️ 풀 노드를 실행해야 하는가?

- 블록체인의 건전성(health), 복원력(resilience), 검열 저항(censorship resistance)특성은 독립적으로 운용되고 지리적으로 분산된 풀 노드가 얼마나 많은지에 달려 있다.

- 각각의 풀 노드는 다른 새 노드가 블록데이터를 얻어 작업을 부트스트랩하고, 운영자에게 모든 트랜잭션 및 컨트랙트에 대해 신뢰할 수 있고 독립적인 검증을 제공할 수 있도록 도와준다.

- 그러나 풀 노드를 실행하면 하드웨어 자원 및 대역폭 비용이 발생한다.

- 이더리움 개발에는 풀 노드가 꼭 필요하지는 않다.

- 테스트넷 노드, 가나슈같은 로컬 사설 블록체인 또는 인퓨라 같은 서비스 공급자가 제공하는 클라우드 기반 이더리움 클라이언트로 원하는 대부분의 작업을 수행할 수 있다.

- 블록체인의 사본을 저장하지 않거나 블록 및 트랜잭션의 유효성을 확인하지 않는 원격 클라이언트를 실행할 수도 있다.

- 이 클라이언트는 지갑의 기능을 제공하며 트랜잭션을 생성하고 전파할 수 있다.

- 원격 클라이언트를 사용하여 자신의 풀 노드, 공개 블록체인, 공개 또는 허가된(권위증명, Proof of Authority) 테스트넷 또는 개인 로컬 블록체인 같은 기존 네트워크에 연결할 수 있다.

- '원격 클라이언트'및 '지갑'이라는 용어는 서로 다른 점이 있는데, '원격 클라이언트'는 지갑의 트랜잭션 기능 외에도 API(예를 들어, web.js API)를 제공 한다.

- 블록헤더의 유효성을 검사하고 머클 증명을 사용하여 블록체인에서의 트랜잭션 포함여부를 확인하고 그 영향도를 결정하여 풀 노드에 대해 비슷한 수준의 보안을 제공하는 라이트 클라이언트와 원격 지갑 개념을 혼동하면 안된다.

- 이더리움 원격 클라이언트는 유효성검사를 하지 않는다.

### 🏷️ 풀 노드의 장단점

장점

- 이더리움 기반 네트워크의 복원력과 검열 저항을 지원한다.

- 모든 트랜잭션을 정식으로 검증한다.

- 중개자 없이 공개 블록체인의 모든 컨트랙트와 상호작용할 수 있다.

- 중개자 없이 컨트랙트를 공개 블록체인에 직접 배포할 수 있다.

- 블록체인 상태(계정, 스마트 컨트랙트 등)를 오프라인에서 조회할 수 있다.(읽기 전용)

- 읽은 정보를 제 3자에게 노출하지 않고 가져올 수 있다.

단점

- 하드웨어와 대역폭 자원의 확대가 필요하다.

- 처음 시작할 때 전체 동기화를 위해 여러 날이 소요된다.

- 동기화를 유지하기 위해 관리하고, 업그레이드하고, 온라인 상태로 유지해야 한다.

### 🏷️ 공개 테스트넷의 장단점

장점

- 테스트넷 노드는 훨씬 적은 데이터와 동기화를 필요로 한다.

- 테스트넷 노드는 몇 시간 내에 전체 동기화를 할 수 있다.

- 컨트랙트 배포 및 트랜잭션 생성을 위한 테스트용 이더를 몇몇 Faucet으로부터 무료로 얻을 수 있다.
- 테스트넷은 다른 많은 스마트 컨트랙트가 '동작(live)'실행 중인 공개 블록체인이다.

단점

- 테스트넷에서는 실제 돈을 사용할 수 없다. 따라서 위험에 처할만한 일이 없으므로 악의적 사용자들에 대응하는 실전 보안성 테스트를 할 수 없다.

- 테스트넷에서는 퍼블릭 블록체인에서만큼 실전 테스트를 할 수 없는 측면이 있다. 예를 들면, 테스트넷에서는 실제 트랜잭션시 필수적으로 발생하는 비용인 가스 수수료를 고려하지 않는다. 또 네트워크 혼잡이 없다.

### 🏷️ 로컬 블록체인 시뮬레이션 장단점

장점

- 동기화가 없고 디스크에 데이터가 거의 없다. 직접 첫 번째 블록을 채굴한다.

- 테스트 이더를 얻을 필요가 없다. 테스트를 위해 사용할 수 있는 채굴 보상을 자신에게 수여한다.

- 다른 사용자가 전혀 없다.

- 다른 컨트랙트또한 전혀 없고 자신이 배포한 컨트랙트만 존재하낟.

단점

- 다른 사용자가 없다는 건, 공개 블록체인과 동일하게 동작하지 않는 것이고 트랜잭션 순서나 트랜잭션 공간을 두고 경쟁이 없다.

- 다른 채굴자가 없다는 건, 채굴이 더욱 예측 가능하다는 뜻으로, 공개 블록체인에서 발생하는 일부 시나리오를 테스트할 수 없다.

- 다른 컨트랙트가 없다는 건, 테스트를 위해 의존성을 갖는 것들과 컨트랙트 라이브러리를 포함하여 필요한 모든 것들을 배포해야한다는 것을 의미한다.

- 어떤 시나리오를 테스트하기 위한 공개 컨트랙트와 주소를 다시 만들지 못할 수도 있다(DAO 컨트랙트).

## 📑 이더리움 클라이언트 실행

### 🏷️ 풀 노드를 위한 하드웨어 요구사항

최소 요구사항

- 2코어 이상의 CPU

- 적어도 80GB의 여유 스토리지 공간

- 최소 4G RAM SSD(HDD의 경우 8GB 이상)

- 다운로드 속도가 초당 8MBits인 인터넷 서비스

추천 사양

- 4코어 이상의 빠른 CPU

- 16GB 이상의 RAM

- 메모리 여유 공간이 적어도 500GB인 빠른 SSD

- 다운로드 속도가 초당 25MBit 이상인 인터넷 서비스

### 🏷️ 클라이언트(노드)를 빌드하고 실행하기 위한 소프트웨어 요구사항

- 일반적으로 모든 블록체인에는 자체 버전의 게스가 있다. 패리티는 동일한 클라이언트 다운로드를 통해 여러 이더리움 기반 블록체인을 지원한다.

- 패리티는 OpenSSL과 libudev같은 소프트웨어 라이브러리가 필요하다.

  ```shell
  $ sudo apt-get install openssl libssl-dev libudev-dev cmake clang
  ```

### 🏷️ 패리티 (Parity)

- 패리티는 풀 노드 이더리움 클라이언트 및 댑 브라우저를 구현한 것이다.

#### 🏳️ 패리티 설치

```shell
$ git clone https://github.com/paritytech/parity

$ cd parity
$ cargo install

$ parity --version
```

### 🏷️ 게스 (Go-Ethereum, Geth)

- 이더리움 재단에서 고 언어로 개발하였으며 이더리움의 공식 클라이언트이다. 일반적으로 모든 이더리움 기반 블록체인은 자체 게스 구현을 갖고 있다.

#### 🏳️ 저장소 클론

- 블록체인에 적합한 저장소 링크를 찾아서 클론한다.

```shell
$ git clone <저장소 링크>

$ cd go-ethereum
$ make geth

$ ./build/bin/geth version  # 게스를 실행하지 않고 구동 가능한 상태인지 확인
```

- 아직은 게스를 실행하면 안된다. 블록체인을 느린 방법으로 동기화하기 때문이다.

## 📑 이더리움 기반 블록체인의 첫 번째 동기화

- 일반적으로 이더리움 블록체인을 동기화할 때 클라이언트는 처음부터, 즉 제네시스 블록이후 모든 블록 및 트랜잭션을 다운로드하고 유효성을 검사한다.

- 동기화는 매우 오래 걸리고 많은 자원을 필요로 한다.

- 많은 이더리움 기반 블록체인이 2016년 말 서비스 거부 공격을 받았다. 공격을 받은 블록체인은 전체 동기화를 수행할 때 천천히 동기화되는 경향이 있다.

- 공격을 받은 블록은 블록당 1분을 초과하는 유효성 검사시간이 요구된다.

- 이더리움은 하드 포크를 사용하여 서비스 거부 공격에서 악용된 근본 취약점을 해결하기 위해 업그레이드했다.

- 이러한 업그레이드를 통해, 스팸 트랜잭션으로 만들어진 2천만 개의 빈 계정을 삭제하여 블록체인을 정리했다.

- 대부분의 이더리움 클라이언트는 빠른 동기화를 수행하는 옵션을 포함한다. 게스의 경우 --fast, 패리티는 기본적으로 지원

### 🏷️ JSON-RPC 인터페이스

- 이더리움 클라이언트는 애플리케이션 인터페이스와 JSON(JavaScript Object Notation)으로 인코딩된 RPC(Remote Procedure Call) 명령을 제공한다.

- 기본적으로 JSON-RPC API는 이더리움 클라이언트를 이더리움 네트워크 및 블록체인의 게이트웨이로 사용하는 프로그램을 작성할 수 있게 해주는 인터페이스다.

- 일반적으로 RPC 인터페이스는 포트 8545에서 HTTP 서비스로 제공된다.

- JSON-RPC API에 접근하려면 사용가능한 각 RPC 명령에 해당하는 스텁(stub)함수 호출을 제공하는 특수 라이브러리를 사용하거나, HTTP 요청과 JSON으로 인코딩된 보내기/받기 요청을 수동으로 생성할 수 있다. curl같은 일반적인 커맨드라인 HTTP 클라이언트를 사용하여 RPC인터페이스를 호출할 수도 있다.

```shell
$ curl -X POST -H "Content-Type: application/json" --data \
'{"jsonrpc":"2.0","method":"web3_clientVersion","params":[],"id":1}' \
http://localhost:8545
```

- HTTP POST 요청을 사용하고 Content-Type: application/json 유형의 콘텐츠를 식별하기 위해 curl을 지기한다. 마지막으로, HTTP 요청의 데이터 요소로서 JSON으로 인코딩된 요청을 전달한다.

```shell
$ curl -X POST -H "Content-Type: application/json" --data \
'{"jsonrpc":"2.0","method":"eth_gasPrice","params":[],"id":4213}' \
http://localhost:8545     # 가스 가격을 확인하는 요청
```

## 📑 원격 이더리움 클라이언트

- 이더리움 클라이언트는 일반적으로 다음 기능 중 하나 이상을 제공한다.

  - 개인키와 이더리움 주소를 지갑에서 관리

  - 트랜잭션 생성, 서명 및 브로드캐스트

  - 데이터 페이로드를 사용하여 스마트 컨트랙트와 상호연동

  - 브라우저와 댑 간 상호연동

  - 블록 탐색기 같은 외부 서비스 링크

  - 이더 단위를 변환하고 외부 소스에서 환율을 검색

  - 자바스크립트 객체로서 web3 인스턴스를 웹 브라우저에 삽입

  - 다른 클라이언트가 브라우저에 제공/삽입한 web3 인스턴스를 사용

  - 로컬 또는 원격 이더리움 노드에서 RPC 서비스로 접근

- 모바일 지갑 같은 원격 클라이언트는 기본적인 지갑 기능만 제공한다. 다른 원격 클라이언트는 모든 기능을 갖춘 댑 브라우저다.
