# 🖇️ 이더리움 기초

## 📑 이더 화폐 단위

- 이더리움의 화폐 단위는 **이더(Ether)** 라고 불리며 'ETH'또는 기호 Ξ 또는 자주 쓰이지 않지만 🔷를 사용한다.

- 이더는 더 작은 단위로 세분화되어 **웨이(wei)** 라는 가능한 가장 작은 단위까지 내려간다. 1개의 이더는 10^18웨이이고 10^9웨이는 1Gwei이다.

## 📑 이더리움 지갑 선택하기

- 이더리움 계정을 관리하는 데 도움이 되는 소프트웨어 어플리케이션이라는 의미로 **지갑**이라는 용어를 사용한다.

- 즉 이더리움 지갑은 이더리움 시스템의 관문이다. 지갑은 사용자의 키를 보유하고, 사용자를 대신하여 트랜잭션을 생성하고 브로드캐스트할 수 있다.

## 📑 통제와 책임

- 이더리움의 각 사용자가 자금 및 스마트 컨트랙트에 대한 접근을 제어하는 자체 개인키를 관리하고 제어할 수 있어야 한다.

- 기본 원칙은 하나의 개인키가 하나의 '계정'과 동일한 것이라고 생각하면 쉽다.

## 📑 메타마스크에서 이더 보내기

- 정확히 1ETH를 가지고 있고 1ETH를 보내고 싶다. 하지만 이 이더를 보내려고 할 때 메타마스크는 충분한 자금이 없다고 오류를 보낸다.

- 이더 트랜잭션은 모든 트랜잭션이 유효한지 확인하기 위해 채굴자에게 수수료를 지급해야 한다. 이더리움의 수수료는 **가스(gas)** 라고 하는 암호화폐로 청구된다. 트랜잭션의 부분 구성요소로 가스를 포함하는데, 이더로 가스비를 지불한다.

## 📑 월드 컴퓨터 소개

- 암호화폐 기능은 탈중앙화된 월드 컴퓨터로서 이더리움의 기능에 부차적인 것이다.

- 이더는 이더리움 가상머신, EVM이라고 하는 에뮬레이트된 컴퓨터에서 실행되는 컴퓨터 프로그램인 스마트 컨트랙트를 실행하는데 사용되기 위한 것이다.

- EVM은 글로벌 싱글톤으로, 마치 전 세계에 걸친 단일 인스턴스 컴퓨터인 것처럼 작동하며 세상 어디에서든 실행된다.

- 이더리움 네트워크의 각 노드는 컨트랙트 실행을 확인하기 위해 EVM의 로컬 사본을 실행하고, 이더리움 블록체인은 트랜잭션과 스마트 컨트랙트를 처리할 때 월드 컴퓨터의 변화하는 상태(state)를 기록한다.

## 📑 외부 소유 계정(EOA)및 컨트랙트

- 메타마스크 지갑에서 생성한 계정의 유형을 **외부 소유 계정(Externally Owned Account, EOA)** 이라고 한다.

- EOA는 개인키가 있는 계정이고 이는 자금 또는 컨트랙트에 대한 접근을 제어함을 의미한다.

- 컨트랙트 계정에는 스마트 컨트랙트코드가 있고 개인키가 없다.

- 개인키가 없는 대신, 스마트 컨트랙트 코드의 로직으로 제어한다.

- 스마트 컨트랙트 코드는 컨트랙트 계정 생성 시 이더리움 블록체인에 기록되고 EVM에 의해 실행되는 소프트웨어 프로그램이다.

- 트랜잭션에는 이더외에도 실행할 컨트랙트의 특정 함수와 해당 함수에 전달할 파라미터를 나타내는 데이터가 포함될 수 있고 이렇게 해서 트랜잭션은 컨트랙트 내의 함수를 호출할 수 있다.

- 컨트랙트에는 개인키가 없기 때문에 트랜잭션을 시작할 수 없고 EOA만 트랜잭션을 시작할 수 있지만, 컨트랙트는 복잡한 실행경로를 구축하여 다른 컨트랙트를 호출해서 컨트랙트에 반응할 수 있다.

## 📑 간단한 컨트랙트: 테스트 이더 Faucet

```solidity
contract Faucet {
    function withdraw(uint withdraw_amount) public {
        require(withdraw_amount <= 1 ether);

        msg.sender.transfer(withdraw_amount)
    }

    fallback() public payable() {}
}
```

- msg객체는 모든 컨트랙트에서 접근할 수 있는 입력 중 하나로, 이 컨트랙트의 실행을 시작한 트랜잭션을 나타낸다.

- sender속성은 해당 트랜잭션의 발신자 주소이다.

- transfer 함수는 이더를 현재 컨트랙트에서 발신자의 주소로 전송하는 내장 함수이다.

- fallback 함수는 컨트랙트를 실행한 트랜잭션이 컨트랙트에 선언된 함수 또는 어떠한 함수도 지정하지 않았거나 데이터를 포함하지 않은 경우에 호출된다.

- 이러한 이유로 public, payable로 정의되며 이더를 컨트랙트에 받아들일 수 있음을 의미한다. 이더를 지갑같은 컨트랙트 주소로 보내는 트랜잭션을 발생시키면 이 함수가 처리한다.

## 📑 블록체인에 컨트랙트 생성하기

- 블록체인에 컨트랙트를 등록하는 것은 목적지 주소가 0x0000... (제로 어드레스)인 특수 트랜잭션을 만드는 것이다.

## 📑 컨트랙트 사용하기

### 컨트랙트에서 출금하기

- withdraw함수를 실행시켜도 컨트랙트 주소의 기록에서 OUT 트랜잭션을 보지 못한다.

- 컨트랙트 주소 기록 페이지의 Internal Transaction탭에서 볼 수 있는데 `msg.sender.transfer(withdraw_amount)`는 컨트랙트 코등서 시작되었기 때문에 내부 트랜잭션(message라고도 함)이다.

- 정리하면 withdraw 함수를 호출하는 데이터 명령어가 포함된 트랜잭션을 보내고, 이 트랜잭션으로 컨트랙트가 EVM 내부에서 실행되었다. transfer 함수가 실행되면 내부 트랜잭션이 생성되어 정해진 만큼의 이더가 컨트랙트 잔액에서 `msg.sender`의 지갑 잔액으로 ㄷ르어온다.
