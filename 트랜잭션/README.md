# 💸 트랜잭션

- 트랜잭션은 외부 소유 계정(EOA)에 의해 서명된 메시지로 이더리움 네트워크에 의해 전송되고 이더리움 블록체인에 기록된다.

- 다른 관점으로 바라보면 트랜잭션은 EVM에서 상태 변경을 유발하거나 컨트랙트를 실행할 수 있는 **유일한 방법**이다.

- 이더리움은 글로벌 싱글톤 상태 머신이며, 트랜잭션은 이 상태 머신을 움직여서 상태를 변경할 수 있도록 만든다.

- 컨트랙트는 독자적으로 실행되지 않는다. 또한 이더리움도 자율적으로 실행되지 않는다. 모든 것은 트랜잭션으로부터 시작된다.

## #️⃣ 트랜잭션 구조

- 트랜잭션은 다음 데이터를 포함하는 시리얼라이즈된 바이너리 메시지다.

  1. 논스
  2. 가스 가격
  3. 가스 한도
  4. 수신자
  5. 값
  6. 데이터
  7. v, r, s

- 트랜잭션 메시지의 구조는 RLP(Recursive Length Prefix) 인코딩 체계를 사용하여 시리얼라이즈 된다. 이더리움의 모든 숫자는 8비트 배수 길이의 빅엔디언 정수로 인코딩된다.

- 발신자 EOA를 식별하는 주소에 발신자(from)데이터가 없는데, 이것은 EOA의 공개키를 ECDSA 서명의 v, r, s 구성요소로부터 알아낼 수 있으며, 이는 공개키를 통해 주소를 알아낼 수 있음을 의미한다. 즉, 주소는 공개키에서 파생될 수 있다.

- 클라이언트 소프트웨어에 의해 트랜잭션에 자주 추가되는 다른 메타데이터는 블록번호, 트랜잭션 ID를 포함한다.

## #️⃣ 트랜잭션 논스

- _**논스**_ 란 해당 주소에서 보낸 트랜잭션 건수 또는 연결된 코드가 있는 계쩡의 경우 이 계정에서 만든 컨트랙트 생성 건수와 동일한 스칼라 값

- 논스는 발신 주소의 속성이며 단지 발신 주소의 컨텍스트 안에서만 의미를 갖는다.

- 논스는 명시적으로 블록체인 계정 상태에 저장되지 않고, 해당 주소에서 발생한 확인된 트랜잭션 건수를 세어서 동적으로 계산되는 값이다.

- 논스는 트랜잭션 생성 순서대로 포함된다는 점에서 생기는 사용성상의 기능(usability feature)과 트랜잭션 복지 방제라는 측면의 주요 기능을 갖는다.

### 👉 논스 추적

- getTrasactionCout로 계정이 실행한 트랜잭션의 갯수를 추적할 수 있지만 논스 값을 설정하는 기준으로 사용은 할 수 없다.

- 여러개의 트랜잭션을 보냈을 시 첫 번째 트랜잭션이 보류중이고 나머지 트랜잭션이 대기 중이라면 나머지 트랜잭션은 count되지 않는다. 이 대기 중인 트랜잭션들을 확인하기 위해서 getTrasactionCount에 의존할 수 없다.

- Parity의 JSON RPC인터페이스에서 parity_nextNonce는 다음으로 사용할 논스 값을 반환해준다.

### ✔️ 논스의 간격, 중복 논스 및 확인

- 트랜잭션을 프로그램을 통해서 생성하는 경우, 특히 여러 독립 프로세스에서 동시에 트랜잭션을 생성하는 경우에는 논스를 추적하는 것이 중요하다.

- 트랜잭션을 회수(recall)하는 것은 불가능하다.

- 논스가 같지만 수신자나 값이 다른 2개의 트랜잭션을 전솽하는 것과 같은 논스의 중복이 일어나면, 그중 하나가 확정되고 하나는 거부된다.어떤 트랜잭션이 확정되는지는그 트랜잭션이 첫유효 노드에 도달하는 순서에 따라결정되므로, 무작위적이다.

### 🅰️ 동시 실행, 트랜잭션 생성 및 논스

- 이더리움은 정의상 작업(노드, 클라이언트, 댑)의 동시 실행을 허용하지만 합의를 통해 싱글톤 상태를 강제하는 시스템이다.

- 동일한 핫 월렛 계정에서 여러 컴퓨터가 트랜잭션을 생성, 서명 및 브로드캐스트 하는 방식을 어떻게 조율할까

  - 단일 컴퓨터를 사용하여 트랜잭션에 서명하는 컴퓨터에는 선착순으로 논스를 할당할 수 있지만 이는 단일 실패지점이 된다.

  - 트랜잭션을 생성하고 논스를 할당하지 않은 후, 이 서명되지 않은 트랜잭션들을 한 노드의 대기열에 로려서 이 노드가 트랜잭션을 서명하고 논스를 관리하게 한다.

- 병목 지점을 어쩔수 없이 받아등리거나, 독립적으로 작동하는 다수의 출금 담당 핫 월렛을 설치하고 중간중간에 각 지갑의 밸런스를 다시 채워주는 형식으로 해결하게끔 만든다.

## #️⃣ 트랜잭션 가스

- 가스는 이더리움의 연료다.

- 이더리움은 가스를 사용하여 트랜잭션이 사용할 수 있는 자원의 양을 제어한다. 이는 전 세계 수천 대의 컴퓨터에서 처리되기 때문이다.

- 개방형(튜링 완전) 모델은 Dos(Denial of Service) 공격이나 실수로 막대한 자원을 소모하는 트랜잭션을 피하기 위해 특정한 형태의 미터링(metering)이 필요하다.

- 지갑은 신속한 트랜잭션 컨펌을 위해 gasPrice를 조정할 수 있고 더 높을 수록 빨리 컨펌이 될 것이다.

- gasLimit은 트랜잭션을 완료하기 위해 트랜잭션을 시도하는 사람이 기꺼이 구매할 수 있는 최대 가스 단위 수를 제공한다. 단순 지급의 경우 21,000개의 가스 단위로 고정된다.

- 가스의 사용은 여행이 완료된 후에 실제 가스 사용량에 따라 요금을 지급하는 주유 회사의 신용 계정과 비슷하다.

- 트랜잭션을 전송할 때 첫 번재 유효성 확인 단계중 하나는 그것이 발생된 계정이 가스 가격 x 가스 요금을 지급할 만큼 충분한 이더를 갖고 있는지 확인하는 것이다. 하지만 계좌에서 실제로 금액이 차감되지는 않는다.

- 실제로 소비된 가스의 요금만 청구되지만 지급할 의사가 있는 최대 금액만큼 충분한 잔액이 있어야 한다.

## #️⃣ 트랜잭션 수신자

- to 필드에 트랜잭션 수신자가 지정된다. 20바이트 이더리움 주소를 포함한다. 이더리움은 이 필드를 따로 검증하지 않고 클라이언트에 검증을 위임한다.

- 개인키를 알 수 없는 공개키로 보내진 이더는 소실된 것으로 간주할 수 있다.

- 이더를 연소시키는데는 지급 채널 및 기타 스마트 컨트랙트에서의 부정 행위를 저지하는 것이나 이더의 양이 유한하므로 이더를 연소시키면 모든 이더 보유자에게 연소된 값을 효과적으로 분배한 것으로 이해할 수 있다.

## #️⃣ 트랜잭션 값과 데이터

- 페이로드(payload)는 값(value)과 데이터(data)라는 2개의 필드에 포함된다.

- 값만 있는 트랜잭션은 지급(payment), 데이터만 있는 트랜잭션은 호출(invocation)이다

### 🅰️ EOA 및 컨트랙트에 값 전달

- 값을 포함하는 이더리움 트랜잭션을 구성하면 지급과 동일하다. 이러한 트랜잭션은 대상 주소가 컨트랙트인지 여부에 따라 다르게 작동한다.

- EOA 주소의 경우나 블록체인의 컨트랙트로 표시되지 않은 주소의 경우 이더리움은 상태 변경을 기록하여 주소 잔액에 보낸 값을 추가한다. 이전에 주소가 표시되지 않은 경우, 클라이언트 내부 상태 표현에 추가되고 잔액은 지급 금액으로 초기화 된다.

- 목적지 주소가 컨트랙트라면 EVM은 컨트랙트를 실행하고 데이터에 따라 함수를 실행하거나 데이터가 없으면 fallback함수를 호출한다. fallback함수가 없다면 트랜잭션의 효과는 지갑에 지급하는 것과 마찬가지로 컨트랙트의 잔액을 늘린다.

### 🅰️ EOA 또는 컨트랙트에 데이터 페이로드 전달

- EOA에 의한 데이터 페이로드의 해석은 컨트랙트 실행과 달리 이더리움의 합의 규칙의 적용을 받지 않는다는 것이다.

- 트랜잭션이 컨트랙트 주소로 데이터를 전달한다고 가정해 보자. 이 경우 데이터는 EVM에 의해 컨트랙트 호출(contract invocation)로서 해석된다. 대부분의 컨트랙트에서는 이 데이터를 함수 호출(function invocation)로 사용한다.

- ABI 호환 컨트랙트(대부분)로 전송된 데이터 페이로드는 다음을 16진수로 시리얼라이즈한 인코딩이다.

  - 함수 선택자 (function selector)
  - 함수 인수 (function argument)

    ```bash
    > web3.sha3("withdraw(uint256)");
    결과 값의 처음 4byte를 취함
    > web3.toHex('10000000000000000') # 0.001 ether
    32바이트 값으로 표시
    ```

    위의 결과를 순서대로 붙인 값을 데이터 페이로드로서 사용한다

## #️⃣ 특별 트랜잭션: 컨트랙트 생성

- 새로운 트랜잭션 중 하나는 블록체인에 새로운 컨트랙트를 만들어 향후 사용을 위해 배포하는 트랜잭션이다.

- 컨트랙트 생성 트랜잭션은 제로 어드레스(0x0)라고 하는 특수 대상 주소로 전송된다.

- 컴파일된 바이트 코드를 포함하는 데이터 페이로드로만 포함하면 된다. 이 트랜잭션의 유일한 효과는 컨트랙트를 작성하는 것이다.

## #️⃣ 디지털 서명

### 🅰️ 타원 곡선 디지털 서명 알고리즘

- 이더리움의 ECDSA(Elliptic Curve Digital Signature Algorithm)은 타원 곡선의 개인키-공개키 쌍을 기반으로 한다.

- 디지털 서명은 이더리움에서 세가지 용도로 사용된다.

  1. 서명은 이더리움 계정과 개인키의 소유자가 이더 지출 또는 컨트랙트 이행을 **승인했음을 증명한다**.
  2. 보낸 사람이 메시지를 보내지 않았음을 부인할 수 없다(**부인방지**, non-repudiation)
  3. 서명은 트랜잭션이 서명된 후에는 트랜잭션 데이터가 수정되지 않았고 어느 누구도 트랜잭션 데이터를 **수정할 수 없음**을 증명한다.

### 🅰️ EIP-155를 사용한 원시 트랜잭션 생성

- '단순 재생 공격 방지'(Simple Replay Attack Protection) 표준은 서명하기 전에 트랜잭션 데이터 내부에 체인 식별자(chain identifier)를 포함하여 재생 공격 방지가 가능한 트랜잭션 인코딩을 지정한다.

## #️⃣ 서명 접두어 값(v) 및 공개키 복구

## #️⃣ 서명 및 전송 분리 (오프라인 서명)

- 트랜잭션 생성, 서명, 브로드캐스트 세 단계는 일반적으로 단일 작업에 의해 처리된다.

- 서명된 트랜잭션이 있으면 web3.eth.sendSignedTransaction을 사용하여 트랜잭션을 16진수로 인코딩하고 서명해서 이더리움 네트워크에 전송할 수 있다.

- 트랜잭션의 서명과 전송을 분리하려는 이유는 보편적으로 보안이다.

- 두 기능이 하나의 컴퓨터에 있으면 온라인 시스템에 개인키가 있게 되며 위험요소가 될 수 있다.

- 각기 다른 시스템에서 이 기능을 수행하는 것을 오프라인 서명이라고 하며 이는 일반적인 보안 방법이다.

## #️⃣ 트랜잭션 전파

- 트랜잭션 전파는 서명된 트랜잭션을 생성(또는 오프라인에서 수신)한 이더리움 노드에서 시작한다.

- 평균적으로 각 이더리움 노드는 이웃(neighbor)이라고 불리는, 적어도 13개의 다른 노드에 대한 연결을 유지한다.

- 결과적으로 트랜잭션은 네트워크의 모든 노드가 트랜잭션 사본을 가질 때까지 원래 노드에서 바깥쪽으로 물결치며 퍼진다.(flooding)

## #️⃣ 블록체인에 기록하기

- 트랜잭션이 블록으로 채워지면 계정의 잔액을 수정하거나(단순 결제의 경우) 내부 상태를 변경하는 컨트랙트를 호출하여 트랜잭션은 이더리움 싱글톤 상태를 수정한다.

- 이러한 변경사항은 이벤트가 포함될 수 있는 트랜잭션 영수증(receipt) 형식으로 트랜잭션과 함께 기록된다.

- 채굴까지 완료된 트랜잭션은 싱글톤의 상태를 변경하고 블록체인에서 지울 수 없는 기록을 남긴다.

## ️#️⃣ 다중 서명 트랜잭션

- 이 기능을 이용하려면 이더를 다중 서명 요구사항이나 지출한도와 같이 원하는 지출 규칙으로 프로그래밍한 '지갑 컨트랙트'로 보내야 한다.

- 스마트 컨트랙트로 다중 서명 트랜잭션을 구현하는 기능은 이더리움의 유연성을 입증한다. 그러나 이러한 유연성으로 인해 다중 서명 체계의 보안을 약화시키는 버그가 발생할 수 있으므로 양날의 검이다.

- 실제로 간단한 'M of N'다중 서명 구성을 스마트 컨트랙트를 이용하지 않고 EVM에서 직접 다중 서명 명령을 처리하게 하자는 제안이 많다.
